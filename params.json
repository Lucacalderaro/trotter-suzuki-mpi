{"name":"Trotter-suzuki-mpi","tagline":"Distributed Trotter-Suzuki solver","body":"Distributed Trotter-Suzuki Solver\r\n==\r\n\r\nThis is a distributed variant of efficient implementations of a simple Trotter-Suzuki solver. The kernels are based on the efficient [implementation](https://bitbucket.org/zzzoom/trottersuzuki) by \r\nCarlos Bederi√°n\r\n\r\nDependencies\r\n==\r\nCUDA and an MPI implementation are required for compiling. It also require a GPU with at least Compute Cabapility 2.0 for the CUDA kernel to execute.\r\n\r\nUsage\r\n==\r\n\r\nA test example is included. Usage: trottertest [OPTIONS]. \r\n\r\nArguments:\r\n\r\n    -d NUMBER     Matrix dimension (default: 640)\r\n    -i NUMBER     Number of iterations (default: 1000)\r\n    -k NUMBER     Kernel type (default: 0): \r\n                    0: CPU, cache-optimized\r\n                    1: CPU, SSE and cache-optimized\r\n                    2: GPU\r\n                    3: Hybrid CPU-GPU (experimental)                    \r\n    -s NUMBER     Snapshots are taken at every NUMBER of iterations.\r\n                    Zero means no snapshots. Default: 0.\r\n\r\nExample:\r\n\r\n    mpirun -np 4 build/trottertest -k 0 -i 100 -d 640 -s 10\r\n\r\nIn case of the SSE kernel, the chunk of the matrix assigned to a node, that is a tile, must have a width that is divisible by two. This puts a constraint on the possible matrix sizes. For instance, running twelve MPI threads in a 4x3 configuration, the dimensions must be divisible by six and eight.\r\n\r\nThe hybrid kernel is experimental. It splits the work between the GPU and the CPU. It uses one MPI thread per GPU, and uses OpenMP to use parallelism on the CPU. It is efficient if the matrix does not fit the GPU memory. For instance, given twelve physical cores in a single node with two Tesla C2050 GPUs, a 14,000x14,000 would not fit the GPU memory. The following command would calculate the part that does not fit the device memory on the CPU:\r\n\r\n    OMP_NUM_THREADS=6 mpirun -np 2 build/trottertest -k 3 -i 100 -d 14000\r\n\r\nThe included shell script single2double.sh generates a double precision variant. Executing it will overwrite the single precision source code.\r\n\r\nCitation\r\n==\r\nFurther details are available in the following paper:\r\n\r\nWittek, P. and Cucchietti, F.M. (2013). [A Second-Order Distributed Trotter-Suzuki Solver with a Hybrid CPU-GPU Kernel](http://dx.doi.org/10.1016/j.cpc.2012.12.008). Computer Physics Communications, 184, pp. 1165-1171. [PDF](http://arxiv.org/pdf/1208.2407)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}